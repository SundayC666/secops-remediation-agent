#!/usr/bin/env python3
# /// script
# requires-python = ">=3.9"
# dependencies = ["httpx>=0.28"]
# ///
"""
NVD CVE Lookup - Query NIST NVD for vulnerabilities using CPE-based search.
Supports product name search and direct CVE ID lookup.
"""

import argparse
import json
import sys
import time
from datetime import datetime
from typing import Dict, List, Optional, Tuple

import httpx

NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"

# CPE mapping: keyword -> (vendor, product, cpe_type) or list of tuples
# cpe_type: 'o' = OS, 'a' = application, 'h' = hardware
CPE_MAPPING: Dict[str, any] = {
    # Microsoft Windows
    "windows": [
        ("microsoft", "windows_10_22h2", "o"),
        ("microsoft", "windows_11_24h2", "o"),
    ],
    "windows 10": [
        ("microsoft", "windows_10_22h2", "o"),
        ("microsoft", "windows_10_21h2", "o"),
        ("microsoft", "windows_10_1809", "o"),
    ],
    "windows 11": [
        ("microsoft", "windows_11_24h2", "o"),
        ("microsoft", "windows_11_23h2", "o"),
        ("microsoft", "windows_11_22h2", "o"),
        ("microsoft", "windows_11_21h2", "o"),
    ],
    "windows server": [
        ("microsoft", "windows_server_2022", "o"),
        ("microsoft", "windows_server_2019", "o"),
        ("microsoft", "windows_server_2016", "o"),
    ],
    # Apple
    "macos": [("apple", "macos", "o"), ("apple", "mac_os_x", "o")],
    "ios": [("apple", "iphone_os", "o")],
    "ipados": [("apple", "ipados", "o"), ("apple", "iphone_os", "o")],
    "safari": ("apple", "safari", "a"),
    # Linux
    "linux": [("linux", "linux_kernel", "o")],
    "ubuntu": [("canonical", "ubuntu_linux", "o")],
    "debian": [("debian", "debian_linux", "o")],
    "redhat": [("redhat", "enterprise_linux", "o")],
    "rhel": [("redhat", "enterprise_linux", "o")],
    "centos": [("centos", "centos", "o"), ("centos", "centos_stream", "o")],
    "fedora": [("fedoraproject", "fedora", "o")],
    "rocky linux": ("rocky", "rocky", "o"),
    "arch linux": ("archlinux", "arch_linux", "o"),
    # Android
    "android": [("google", "android", "o")],
    # Browsers
    "chrome": [("google", "chrome", "a")],
    "google chrome": ("google", "chrome", "a"),
    "firefox": [("mozilla", "firefox", "a"), ("mozilla", "firefox_esr", "a")],
    "edge": [("microsoft", "edge", "a"), ("microsoft", "edge_chromium", "a")],
    # Microsoft Products
    "office": [("microsoft", "365_apps", "a"), ("microsoft", "office", "a")],
    "exchange": [("microsoft", "exchange_server", "a")],
    "outlook": ("microsoft", "outlook", "a"),
    "teams": ("microsoft", "teams", "a"),
    "sharepoint": ("microsoft", "sharepoint_server", "a"),
    "azure": ("microsoft", "azure", "a"),
    "sql server": ("microsoft", "sql_server", "a"),
    ".net": ("microsoft", ".net", "a"),
    "powershell": ("microsoft", "powershell", "a"),
    # Adobe
    "acrobat": [("adobe", "acrobat_dc", "a"), ("adobe", "acrobat", "a")],
    "adobe reader": ("adobe", "acrobat_reader_dc", "a"),
    "photoshop": ("adobe", "photoshop", "a"),
    "coldfusion": ("adobe", "coldfusion", "a"),
    # Oracle/Java
    "java": [("oracle", "jdk", "a"), ("oracle", "jre", "a")],
    "mysql": [("oracle", "mysql", "a"), ("mysql", "mysql", "a")],
    "weblogic": ("oracle", "weblogic_server", "a"),
    # Web Servers
    "apache": [("apache", "http_server", "a")],
    "nginx": ("nginx", "nginx", "a"),
    "tomcat": ("apache", "tomcat", "a"),
    "iis": ("microsoft", "internet_information_services", "a"),
    "haproxy": ("haproxy", "haproxy", "a"),
    "traefik": ("traefik", "traefik", "a"),
    # Databases
    "postgresql": ("postgresql", "postgresql", "a"),
    "postgres": ("postgresql", "postgresql", "a"),
    "mariadb": ("mariadb", "mariadb", "a"),
    "mongodb": ("mongodb", "mongodb", "a"),
    "redis": ("redis", "redis", "a"),
    "elasticsearch": ("elastic", "elasticsearch", "a"),
    # Containers & Orchestration
    "docker": [("docker", "docker", "a"), ("mobyproject", "moby", "a")],
    "kubernetes": ("kubernetes", "kubernetes", "a"),
    "k8s": ("kubernetes", "kubernetes", "a"),
    "openshift": ("redhat", "openshift", "a"),
    "containerd": ("linuxfoundation", "containerd", "a"),
    "podman": ("podman_project", "podman", "a"),
    "helm": ("helm", "helm", "a"),
    # CI/CD & DevOps
    "jenkins": ("jenkins", "jenkins", "a"),
    "gitlab": ("gitlab", "gitlab", "a"),
    "github enterprise": ("github", "enterprise_server", "a"),
    "jira": ("atlassian", "jira", "a"),
    "confluence": ("atlassian", "confluence", "a"),
    "ansible": ("redhat", "ansible", "a"),
    "terraform": ("hashicorp", "terraform", "a"),
    "vault": ("hashicorp", "vault", "a"),
    "argocd": ("argoproj", "argo_cd", "a"),
    # CMS
    "wordpress": ("wordpress", "wordpress", "a"),
    "drupal": ("drupal", "drupal", "a"),
    # Languages & Runtimes
    "python": ("python", "python", "a"),
    "node.js": ("nodejs", "node.js", "a"),
    "nodejs": ("nodejs", "node.js", "a"),
    "php": ("php", "php", "a"),
    "ruby": ("ruby-lang", "ruby", "a"),
    "go": ("golang", "go", "a"),
    "golang": ("golang", "go", "a"),
    "rust": ("rust-lang", "rust", "a"),
    # Networking & Security
    "cisco": [("cisco", "ios", "o"), ("cisco", "ios_xe", "o")],
    "fortinet": [("fortinet", "fortios", "o"), ("fortinet", "fortigate", "h")],
    "fortigate": ("fortinet", "fortios", "o"),
    "palo alto": [("paloaltonetworks", "pan-os", "o")],
    "juniper": ("juniper", "junos", "o"),
    "f5": ("f5", "big-ip_access_policy_manager", "a"),
    # VPN
    "openssl": ("openssl", "openssl", "a"),
    "openvpn": ("openvpn", "openvpn", "a"),
    "wireguard": ("wireguard", "wireguard", "a"),
    # Virtualization
    "vmware": [("vmware", "vcenter_server", "a"), ("vmware", "esxi", "o")],
    "esxi": ("vmware", "esxi", "o"),
    "virtualbox": ("oracle", "vm_virtualbox", "a"),
    "qemu": ("qemu", "qemu", "a"),
    # Cloud
    "aws": ("amazon", "aws", "a"),
    "gcp": ("google", "cloud_platform", "a"),
}


def build_cpe_strings(keyword: str) -> List[str]:
    """Build CPE 2.3 strings from a product keyword."""
    keyword_lower = keyword.lower().strip()
    cpe_strings = []

    # Direct match
    if keyword_lower in CPE_MAPPING:
        mapping = CPE_MAPPING[keyword_lower]
        if isinstance(mapping, list):
            for vendor, product, cpe_type in mapping:
                cpe_strings.append(f"cpe:2.3:{cpe_type}:{vendor}:{product}:*:*:*:*:*:*:*:*")
        else:
            vendor, product, cpe_type = mapping
            cpe_strings.append(f"cpe:2.3:{cpe_type}:{vendor}:{product}:*:*:*:*:*:*:*:*")
        return cpe_strings

    # Try partial match
    for key, mapping in CPE_MAPPING.items():
        if key in keyword_lower or keyword_lower in key:
            if isinstance(mapping, list):
                for vendor, product, cpe_type in mapping:
                    cpe_strings.append(f"cpe:2.3:{cpe_type}:{vendor}:{product}:*:*:*:*:*:*:*:*")
            else:
                vendor, product, cpe_type = mapping
                cpe_strings.append(f"cpe:2.3:{cpe_type}:{vendor}:{product}:*:*:*:*:*:*:*:*")
            return cpe_strings

    # Fallback: treat as generic product
    product = keyword_lower.replace(" ", "_")
    cpe_strings.append(f"cpe:2.3:*:*:{product}:*:*:*:*:*:*:*:*")
    return cpe_strings


def process_nvd_cve(vuln_data: Dict) -> Optional[Dict]:
    """Process a single NVD CVE record into a standardized format."""
    cve = vuln_data.get("cve", {})
    cve_id = cve.get("id", "")
    if not cve_id:
        return None

    # Description
    descriptions = cve.get("descriptions", [])
    description = ""
    for desc in descriptions:
        if desc.get("lang") == "en":
            description = desc.get("value", "")
            break
    if not description and descriptions:
        description = descriptions[0].get("value", "")

    # CVSS metrics (try 3.1, 3.0, 2.0)
    metrics = cve.get("metrics", {})
    cvss_score = None
    severity = "UNKNOWN"
    cvss_vector = ""

    for cvss_key in ["cvssMetricV31", "cvssMetricV30", "cvssMetricV2"]:
        cvss_list = metrics.get(cvss_key, [])
        if cvss_list:
            cvss_data = cvss_list[0].get("cvssData", {})
            cvss_score = cvss_data.get("baseScore")
            severity = cvss_data.get("baseSeverity", "UNKNOWN")
            cvss_vector = cvss_data.get("vectorString", "")
            break

    # Dates
    published = cve.get("published", "")
    last_modified = cve.get("lastModified", "")

    # Affected products
    affected = []
    for config in cve.get("configurations", []):
        for node in config.get("nodes", []):
            for cpe in node.get("cpeMatch", []):
                if cpe.get("vulnerable", False):
                    criteria = cpe.get("criteria", "")
                    if criteria.startswith("cpe:2.3:"):
                        parts = criteria.split(":")
                        if len(parts) >= 6:
                            vendor = parts[3].replace("_", " ").title()
                            product = parts[4].replace("_", " ").title()
                            version_end = cpe.get("versionEndExcluding") or cpe.get("versionEndIncluding")
                            product_str = f"{vendor} {product}" if vendor.lower() != product.lower() else product
                            if version_end:
                                product_str += f" before {version_end}"
                            if product_str not in affected:
                                affected.append(product_str)

    # References and patch links
    references = cve.get("references", [])
    ref_urls = [ref.get("url", "") for ref in references[:10] if ref.get("url")]
    patch_links = [
        ref.get("url", "") for ref in references
        if any(tag in ref.get("tags", []) for tag in ["Patch", "Vendor Advisory"])
    ]

    return {
        "cve_id": cve_id,
        "description": description,
        "severity": severity.upper() if severity else "UNKNOWN",
        "cvss_score": cvss_score,
        "cvss_vector": cvss_vector,
        "published_date": published[:10] if published else "",
        "last_modified": last_modified[:10] if last_modified else "",
        "affected_versions": affected[:20],
        "references": ref_urls,
        "patch_links": patch_links,
    }


def fetch_cves_by_product(product: str, api_key: Optional[str] = None, years: int = 3, limit: int = 50) -> List[Dict]:
    """Fetch CVEs for a product using NVD CPE-based search."""
    cpe_strings = build_cpe_strings(product)
    if not cpe_strings:
        return []

    current_year = datetime.now().year
    min_year = current_year - years
    headers = {"User-Agent": "SecOps-CVE-Triage/1.0"}
    if api_key:
        headers["apiKey"] = api_key

    rate_delay = 0.1 if api_key else 6.0
    all_cves = []
    seen_ids = set()

    with httpx.Client(timeout=30.0) as client:
        for cpe_string in cpe_strings:
            params = {
                "virtualMatchString": cpe_string,
                "resultsPerPage": 100,
                "startIndex": 0,
                "noRejected": "",
            }

            try:
                # Get total count
                resp = client.get(NVD_API_URL, params=params, headers=headers)
                if resp.status_code != 200:
                    print(f"NVD API error: {resp.status_code}", file=sys.stderr)
                    continue

                data = resp.json()
                total = data.get("totalResults", 0)
                if total == 0:
                    continue

                # Scan from end (newest CVE IDs)
                pages = min(4, (total // 100) + 1)
                indices = []
                for i in range(pages):
                    idx = max(0, total - (i + 1) * 100)
                    if idx not in indices:
                        indices.append(idx)

                for start_idx in indices:
                    if len(all_cves) >= limit:
                        break

                    params["startIndex"] = start_idx
                    resp = client.get(NVD_API_URL, params=params, headers=headers)
                    if resp.status_code != 200:
                        continue

                    for vuln in resp.json().get("vulnerabilities", []):
                        published = vuln.get("cve", {}).get("published", "")
                        if published:
                            try:
                                pub_year = int(published[:4])
                                if pub_year >= min_year:
                                    cve_id = vuln.get("cve", {}).get("id", "")
                                    if cve_id and cve_id not in seen_ids:
                                        seen_ids.add(cve_id)
                                        all_cves.append(vuln)
                            except (ValueError, IndexError):
                                pass

                    time.sleep(rate_delay)

            except Exception as e:
                print(f"Error querying NVD: {e}", file=sys.stderr)

    # Process results
    processed = []
    for vuln in all_cves:
        p = process_nvd_cve(vuln)
        if p:
            processed.append(p)

    # Sort by severity then date
    severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3, "UNKNOWN": 4}
    processed.sort(
        key=lambda x: (severity_order.get(x.get("severity", "UNKNOWN"), 4), x.get("published_date", "")),
    )

    return processed[:limit]


def fetch_cve_by_id(cve_id: str, api_key: Optional[str] = None) -> Optional[Dict]:
    """Fetch a specific CVE by ID."""
    headers = {"User-Agent": "SecOps-CVE-Triage/1.0"}
    if api_key:
        headers["apiKey"] = api_key

    try:
        with httpx.Client(timeout=15.0) as client:
            resp = client.get(NVD_API_URL, params={"cveId": cve_id}, headers=headers)
            if resp.status_code == 200:
                vulns = resp.json().get("vulnerabilities", [])
                if vulns:
                    return process_nvd_cve(vulns[0])
    except Exception as e:
        print(f"Error fetching {cve_id}: {e}", file=sys.stderr)

    return None


def main():
    parser = argparse.ArgumentParser(description="Query NIST NVD for CVE vulnerabilities")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--product", help="Product name to search (e.g., 'windows 11', 'nginx')")
    group.add_argument("--cve", help="Specific CVE ID (e.g., CVE-2024-21351)")
    parser.add_argument("--api-key", help="NVD API key (optional, increases rate limit)")
    parser.add_argument("--years", type=int, default=3, help="Lookback years (default: 3)")
    parser.add_argument("--limit", type=int, default=50, help="Max results (default: 50)")
    args = parser.parse_args()

    if args.cve:
        result = fetch_cve_by_id(args.cve, args.api_key)
        if result:
            print(json.dumps([result], indent=2))
        else:
            print(json.dumps([]))
    else:
        results = fetch_cves_by_product(args.product, args.api_key, args.years, args.limit)
        print(json.dumps(results, indent=2))


if __name__ == "__main__":
    main()
